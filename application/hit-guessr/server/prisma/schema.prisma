generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  username  String   @unique
  password  String
  avatar    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Game relationships
  gamesAsPlayer1 Game[] @relation("Player1")
  gamesAsPlayer2 Game[] @relation("Player2")
  gameResults    GameResult[]
  sentChallenges Challenge[] @relation("Challenger")
  receivedChallenges Challenge[] @relation("Challenged")

  @@map("users")
}

model Game {
  id        String   @id @default(cuid())
  type      GameType
  status    GameStatus @default(WAITING)
  currentRound Int     @default(1)
  maxRounds    Int     @default(5)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  startedAt DateTime?
  finishedAt DateTime?

  // Players
  player1Id String
  player1   User   @relation("Player1", fields: [player1Id], references: [id])
  player2Id String?
  player2   User?  @relation("Player2", fields: [player2Id], references: [id])

  // Game data
  rounds     Round[]
  results    GameResult[]
  challenge  Challenge?

  @@map("games")
}

model Round {
  id       String @id @default(cuid())
  gameId   String
  game     Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  
  roundNumber Int
  spotifyTrackId String
  trackName      String
  artistName     String
  releaseYear    Int
  previewUrl     String?
  albumImageUrl  String?
  
  createdAt DateTime @default(now())
  
  // Player answers
  answers RoundAnswer[]

  @@unique([gameId, roundNumber])
  @@map("rounds")
}

model RoundAnswer {
  id      String @id @default(cuid())
  roundId String
  round   Round  @relation(fields: [roundId], references: [id], onDelete: Cascade)
  userId  String
  
  guessedArtist    String?
  guessedTrack     String?
  guessedYear      Int?
  submittedAt      DateTime @default(now())
  timeToAnswer     Int? // seconds
  
  // Scoring
  artistScore   Int @default(0)
  trackScore    Int @default(0)
  yearScore     Int @default(0)
  speedBonus    Int @default(0)
  totalScore    Int @default(0)

  @@unique([roundId, userId])
  @@map("round_answers")
}

model GameResult {
  id       String @id @default(cuid())
  gameId   String
  game     Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  userId   String
  user     User   @relation(fields: [userId], references: [id])
  
  totalScore Int
  position   Int // 1st, 2nd place
  
  createdAt DateTime @default(now())

  @@unique([gameId, userId])
  @@map("game_results")
}

model Challenge {
  id        String @id @default(cuid())
  gameId    String @unique
  game      Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  
  challengerId String
  challenger   User   @relation("Challenger", fields: [challengerId], references: [id])
  challengedId String
  challenged   User   @relation("Challenged", fields: [challengedId], references: [id])
  
  message   String?
  status    ChallengeStatus @default(PENDING)
  expiresAt DateTime
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("challenges")
}

enum GameType {
  SOLO
  MULTIPLAYER
}

enum GameStatus {
  WAITING
  IN_PROGRESS
  FINISHED
  CANCELLED
}

enum ChallengeStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}
